<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deepgram Sales Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif; background: #f5f7fa; padding: 20px; }
        .header { background: white; padding: 25px 30px; border-radius: 10px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        h1 { color: #1a1a1a; font-size: 28px; margin-bottom: 10px; }
        .subtitle { color: #666; font-size: 14px; }
        .controls { background: white; padding: 20px 30px; border-radius: 10px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .btn { background: #13EF93; color: #1a1a1a; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; margin-right: 10px; transition: all 0.2s; }
        .btn:hover { background: #0FD47F; transform: translateY(-1px); }
        .btn-secondary { background: #e8eaed; color: #1a1a1a; }
        .btn-secondary:hover { background: #d8dadd; }
        .dashboard-container { background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); margin-bottom: 20px; overflow-x: auto; }
        table { width: 100%; border-collapse: collapse; font-size: 11px; table-layout: auto; }
        thead { background: #f8f9fa; }
        th { padding: 8px 4px; text-align: left; font-weight: 600; color: #333; border-bottom: 2px solid #e0e0e0; white-space: nowrap; cursor: pointer; user-select: none; position: relative; font-size: 11px; }
        th:hover { background: #e8eaed; }
        th.sortable::after { content: ' ‚áÖ'; color: #ccc; font-size: 9px; }
        th.sort-asc::after { content: ' ‚ñ≤'; color: #13EF93; }
        th.sort-desc::after { content: ' ‚ñº'; color: #13EF93; }
        td { padding: 6px 4px; border-bottom: 1px solid #f0f0f0; max-width: 150px; overflow: hidden; text-overflow: ellipsis; }
        tr:hover { background: #f8f9fa; }
        .renewal-warning { background: #FFF9E6 !important; border-left: 4px solid #FFA500; }
        .renewal-warning:hover { background: #FFF3CD !important; }
        .product-tag { display: inline-block; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin: 1px; font-weight: 500; }
        .tag-batch { background: #E3F2FD; color: #1976D2; }
        .tag-realtime { background: #E8F5E9; color: #388E3C; }
        .tag-voice { background: #F3E5F5; color: #7B1FA2; }
        .tag-flux { background: #FFF3E0; color: #F57C00; }
        .tag-medical { background: #E0F2F1; color: #00796B; }
        .tag-tts { background: #FCE4EC; color: #C2185B; }
        .tag-language { background: #F3E5F5; color: #6A1B9A; }
        .percentage-cell { font-weight: 600; padding: 4px 6px; border-radius: 3px; text-align: center; font-size: 11px; }
        .status-green { background: #d4edda; color: #155724; }
        .status-yellow { background: #fff3cd; color: #856404; }
        .status-red { background: #f8d7da; color: #721c24; }
        .currency { font-family: 'SF Mono', 'Monaco', 'Courier New', monospace; font-size: 11px; }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px; }
        .stat-card { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 8px; }
        .stat-card:nth-child(2) { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
        .stat-card:nth-child(3) { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }
        .stat-card:nth-child(4) { background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); }
        .stat-label { font-size: 12px; opacity: 0.9; margin-bottom: 5px; }
        .stat-value { font-size: 24px; font-weight: 700; }
        .editable { cursor: pointer; position: relative; }
        .editable:hover { background: #f0f0f0; outline: 2px solid #13EF93; outline-offset: -2px; }
        .editing { background: white !important; }
        .edit-input { width: 100%; border: 2px solid #13EF93; padding: 6px; font-size: 13px; font-family: inherit; box-sizing: border-box; }
        .edit-textarea { width: 100%; min-height: 60px; border: 2px solid #13EF93; padding: 6px; font-size: 13px; font-family: inherit; box-sizing: border-box; }
        .action-btn { background: none; border: none; cursor: pointer; padding: 2px 4px; color: #666; font-size: 14px; transition: color 0.2s; }
        .action-btn:hover { color: #13EF93; }
        .save-indicator { position: fixed; top: 20px; right: 20px; background: #13EF93; color: #1a1a1a; padding: 10px 20px; border-radius: 6px; font-weight: 600; display: none; animation: slideIn 0.3s; z-index: 1001; }
        @keyframes slideIn { from { transform: translateX(100px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); }
        .modal-content { background: white; margin: 10% auto; padding: 30px; border-radius: 10px; width: 90%; max-width: 500px; animation: slideDown 0.3s; }
        @keyframes slideDown { from { transform: translateY(-50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .close { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; line-height: 20px; }
        .close:hover { color: #000; }
        .form-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 6px; font-weight: 600; color: #333; font-size: 14px; }
        input, select, textarea { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; font-family: inherit; }
        input:focus, select:focus, textarea:focus { outline: none; border-color: #13EF93; }
        .api-status { display: inline-block; padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 600; margin-left: 8px; }
        .api-loading { background: #FFF3CD; color: #856404; }
        .api-success { background: #D4EDDA; color: #155724; }
        .api-error { background: #F8D7DA; color: #721C24; }
        .tabs { display: flex; gap: 10px; margin-bottom: 20px; background: white; padding: 10px 20px; border-radius: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .tab { padding: 10px 20px; cursor: pointer; border-radius: 6px; font-weight: 600; transition: all 0.2s; border: 2px solid transparent; }
        .tab:hover { background: #f0f0f0; }
        .tab.active { background: #13EF93; color: #1a1a1a; border-color: #13EF93; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        #map { height: 600px; border-radius: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .map-container { background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .leaflet-popup-content { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif; }
        .popup-title { font-size: 16px; font-weight: 700; margin-bottom: 8px; color: #1a1a1a; }
        .popup-info { font-size: 13px; color: #666; margin: 4px 0; }
        .popup-credits { font-size: 14px; font-weight: 600; margin-top: 8px; padding-top: 8px; border-top: 1px solid #e0e0e0; }
        .contract-select { padding: 2px 4px; border: 1px solid #ddd; border-radius: 3px; font-size: 11px; cursor: pointer; background: white; }
        .contract-select:focus { outline: none; border-color: #13EF93; }
        .renewal-badge { display: inline-block; padding: 2px 6px; background: #FFA500; color: white; border-radius: 3px; font-size: 9px; font-weight: 600; margin-left: 4px; }
        .compact-cell { max-width: 80px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .wide-cell { max-width: 200px; }
        .narrow-cell { max-width: 60px; }
        .customer-filter { display: grid; grid-template-columns: 16px 1fr; align-items: center; gap: 8px; padding: 5px 8px; border-radius: 4px; transition: background 0.2s; }
        .customer-filter:hover { background: white; }
        .customer-filter input[type="checkbox"] { cursor: pointer; margin: 0; width: 16px; height: 16px; }
        .customer-filter label { cursor: pointer; margin: 0; font-weight: normal; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .zero-date-item { padding: 8px; background: white; border-radius: 4px; border-left: 3px solid #ff6b6b; }
        .zero-date-customer { font-weight: 700; color: #333; margin-bottom: 4px; }
        .zero-date-date { color: #ff6b6b; font-size: 11px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>üéØ Deepgram Sales Dashboard</h1>
        <p class="subtitle">Customer billing & credit tracking | Prepaid consumption model</p>
    </div>
    
    <div class="controls">
        <button class="btn" onclick="addNewCustomer()">‚ûï Add Customer</button>
        <button class="btn" onclick="addNewProspect()">üéØ Add Prospect</button>
        <button class="btn" onclick="showApiKeyModal()">üîë Set API Key</button>
        <button class="btn" onclick="refreshAllBalances()">üîÑ Refresh All Balances</button>
        <button class="btn btn-secondary" onclick="exportToCSV()">üìä Export CSV</button>
        <button class="btn btn-secondary" onclick="resetData()">‚Ü©Ô∏è Reset to Original</button>
    </div>
    
    <div class="save-indicator" id="saveIndicator">‚úì Changes saved</div>
    
    <!-- API Key Modal -->
    <div id="apiKeyModal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 500px;">
            <span class="close" onclick="closeApiKeyModal()">&times;</span>
            <h2 style="margin-bottom: 20px; color: #333;">Configure Deepgram API Key</h2>
            <p style="color: #666; margin-bottom: 20px; font-size: 14px;">
                Enter your Deepgram API key to fetch live balance data. The key will be stored locally in your browser.
            </p>
            <div class="form-group">
                <label for="apiKeyInput">Deepgram API Key</label>
                <input type="password" id="apiKeyInput" placeholder="Enter your API key" style="font-family: monospace;">
            </div>
            <div style="margin-top: 25px; display: flex; gap: 10px;">
                <button class="btn" style="flex: 1;" onclick="saveApiKey()">Save API Key</button>
                <button class="btn btn-secondary" onclick="closeApiKeyModal()">Cancel</button>
            </div>
        </div>
    </div>
    
    <div class="stats-grid">
        <div class="stat-card">
            <div class="stat-label">Total Customers</div>
            <div class="stat-value" id="totalCustomers">0</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Total Contracted</div>
            <div class="stat-value" id="totalContracted">$0</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Total Remaining</div>
            <div class="stat-value" id="totalRemaining">$0</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">At Risk (< 25%)</div>
            <div class="stat-value" id="atRiskCount">0</div>
        </div>
    </div>
    
    <div class="tabs">
        <div class="tab active" onclick="switchTab('customers')">üë• Customers</div>
        <div class="tab" onclick="switchTab('prospects')">üéØ Prospects</div>
        <div class="tab" onclick="switchTab('concurrency')">‚ö° Concurrency</div>
        <div class="tab" onclick="switchTab('map')">üó∫Ô∏è Map View</div>
        <div class="tab" onclick="switchTab('trends')">üìà Usage Trends</div>
    </div>
    
    <div id="customersView" class="tab-content active">
        <div class="dashboard-container">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h2 style="margin: 0; color: #333;">Active Customers</h2>
                <button class="btn" onclick="addNewCustomer()">‚ûï Add Customer</button>
            </div>
            <table id="customerTable">
                <thead>
                    <tr>
                        <th class="sortable" data-sort="name">Customer</th>
                        <th class="sortable" data-sort="location">Location</th>
                        <th class="sortable" data-sort="useCase">Use Case</th>
                        <th>Products</th>
                        <th class="sortable" data-sort="whitespace">Whitespace</th>
                        <th class="sortable" data-sort="projectId">Project ID</th>
                        <th class="sortable" data-sort="balanceId">Balance ID</th>
                        <th class="sortable" data-sort="startDate">Start Date</th>
                        <th class="sortable" data-sort="contractEndDate">Contract End Date</th>
                        <th class="sortable" data-sort="startingCredits">Starting Credits</th>
                        <th class="sortable" data-sort="creditsRemaining">Credits Remaining</th>
                        <th class="sortable" data-sort="percentage">%</th>
                        <th class="sortable" data-sort="notes">Notes</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="customerTableBody"></tbody>
            </table>
        </div>
    </div>
    
    <div id="concurrencyView" class="tab-content">
        <div class="dashboard-container">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h2 style="margin: 0; color: #333;">Hosted Customers - Concurrency Tracking</h2>
                <div>
                    <label style="font-size: 13px; color: #666; margin-right: 8px;">Peak Period:</label>
                    <select id="peakPeriodSelect" class="contract-select" onchange="updatePeakPeriod(this.value)" style="padding: 6px 12px; font-size: 13px;">
                        <option value="24h" selected>Last 24 Hours</option>
                        <option value="7d">Last 7 Days</option>
                        <option value="30d">Last 30 Days</option>
                        <option value="90d">Last 90 Days</option>
                        <option value="all">All Time</option>
                    </select>
                </div>
            </div>
            <table id="hostedConcurrencyTable">
                <thead>
                    <tr>
                        <th class="sortable" data-sort="name">Customer</th>
                        <th class="sortable" data-sort="concurrencyLimit">Concurrency Limit</th>
                        <th class="sortable" data-sort="currentConcurrency">Current Usage</th>
                        <th class="sortable" data-sort="peakConcurrency" id="peakHeader">Peak (24h)</th>
                        <th class="sortable" data-sort="utilizationPct">Utilization %</th>
                        <th>Products</th>
                        <th class="sortable" data-sort="notes">Notes</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="hostedConcurrencyTableBody"></tbody>
            </table>
        </div>
        
        <div class="chart-container" style="margin-top: 20px;">
            <h2 style="margin-bottom: 20px; color: #333;">Hosted Concurrency Usage Over Time</h2>
            <div class="chart-wrapper" style="height: 400px;">
                <canvas id="concurrencyChart"></canvas>
            </div>
        </div>
        
        <div class="dashboard-container" style="margin-top: 20px;">
            <h2 style="margin-bottom: 15px; color: #333;">Self-Hosted Customers</h2>
            <table id="selfHostedConcurrencyTable">
                <thead>
                    <tr>
                        <th class="sortable" data-sort="name">Customer</th>
                        <th class="sortable" data-sort="concurrencyLimit">Concurrency Limit</th>
                        <th>Products</th>
                        <th class="sortable" data-sort="notes">Notes</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="selfHostedConcurrencyTableBody"></tbody>
            </table>
        </div>
    </div>
    
    <div id="prospectsView" class="tab-content">
        <div class="dashboard-container">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h2 style="margin: 0; color: #333;">Prospect Pipeline</h2>
                <button class="btn" onclick="addNewProspect()">‚ûï Add Prospect</button>
            </div>
            <table id="prospectTable">
                <thead>
                    <tr>
                        <th class="sortable" data-sort="name">Prospect Name</th>
                        <th class="sortable" data-sort="location">Location</th>
                        <th class="sortable" data-sort="useCase">Use Case</th>
                        <th>Products Interested</th>
                        <th class="sortable" data-sort="stage">Sales Stage</th>
                        <th class="sortable" data-sort="estimatedValue">Est. Contract Value</th>
                        <th class="sortable" data-sort="probability">Probability %</th>
                        <th class="sortable" data-sort="expectedClose">Expected Close</th>
                        <th class="sortable" data-sort="lastContact">Last Contact</th>
                        <th class="sortable" data-sort="notes">Notes</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="prospectTableBody"></tbody>
            </table>
        </div>
    </div>
    
    <div id="mapView" class="tab-content">
        <div class="map-container">
            <h2 style="margin-bottom: 15px; color: #333;">Customer Locations</h2>
            <div id="map"></div>
        </div>
    </div>
    
    <div id="trendsView" class="tab-content">
        <div class="chart-container">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h2 style="margin: 0; color: #333;">My Account Usage by Month</h2>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button class="btn btn-secondary" onclick="selectAllCustomers()" style="font-size: 12px; padding: 6px 12px;">Select All</button>
                    <button class="btn btn-secondary" onclick="deselectAllCustomers()" style="font-size: 12px; padding: 6px 12px;">Deselect All</button>
                </div>
            </div>
            <div style="display: flex; gap: 20px; margin-bottom: 20px;">
                <div style="flex: 1; max-height: 500px; overflow-y: auto; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                    <h3 style="margin-top: 0; font-size: 14px; color: #333;">Filter Customers</h3>
                    <div style="margin-bottom: 15px;">
                        <input type="text" id="customerSearch" placeholder="üîç Search customers..." style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 6px; font-size: 13px; margin-bottom: 10px;" oninput="filterCustomerList(this.value)">
                        <div class="customer-filter" style="border-bottom: 1px solid #ddd; padding-bottom: 8px; margin-bottom: 8px;">
                            <input type="checkbox" id="selectAllCheckbox" onchange="toggleAllCustomers(this.checked)" checked>
                            <label for="selectAllCheckbox" style="font-weight: 600;">Select All (<span id="selectedCount">0</span>)</label>
                        </div>
                    </div>
                    <div id="customerFilters" style="display: grid; grid-template-columns: 1fr; gap: 4px; font-size: 12px;"></div>
                </div>
                <div style="flex: 3;">
                    <div class="chart-wrapper" style="height: 500px;">
                        <canvas id="trendsChart"></canvas>
                    </div>
                </div>
            </div>
            <div style="margin-top: 20px; padding: 15px; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 8px;">
                <h3 style="margin-top: 0; font-size: 14px; color: #333;">‚ö†Ô∏è Projected Zero Dates</h3>
                <div id="zeroProjections" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; font-size: 12px;"></div>
            </div>
        </div>
        
        <div class="chart-container" style="margin-top: 20px;">
            <h2 style="margin-bottom: 20px; color: #333;">Total Spend by Product</h2>
            <div class="chart-wrapper" style="height: 450px;">
                <canvas id="spendChart"></canvas>
            </div>
            <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                <p style="color: #666; font-size: 13px; margin: 0;">
                    <strong>üí∞ Spend Breakdown:</strong> Track total spending by product type over time. Stacked areas show the contribution of each product to total spend. 
                    Use this to identify which products drive the most revenue and spot spending trends.
                </p>
            </div>
        </div>
    </div>
    
    <script>
        const originalCustomers = [
            { name: "Nova AI", location: "Ohio", useCase: "Voice Agent", products: ["Batch STT"], whitespace: "Medical, Language Expansion", projectId: "", balanceId: "", startDate: "1/24/25", contractEndDate: "1/24/26", startingCredits: 20000, creditsRemaining: 12879, isHosted: true, concurrencyLimit: 50, currentConcurrency: 32, peak24h: 45, peak7d: 48, peak30d: 50, peak90d: 50, peakAll: 50, notes: "1:1 match by EOM" },
            { name: "Brightside", location: "San Francisco", useCase: "Ambient Medical", products: ["Batch STT", "Medical", "Language Expansion"], whitespace: "", projectId: "", balanceId: "", startDate: "2/28/25", contractEndDate: "2/28/26", startingCredits: 150000, creditsRemaining: 32000, isHosted: true, concurrencyLimit: 100, currentConcurrency: 78, peak24h: 95, peak7d: 98, peak30d: 100, peak90d: 100, peakAll: 100, notes: "billing discrepancy" },
            { name: "Second Nature", location: "CA", useCase: "Mock Sales Voice Agent", products: ["Realtime STT", "Voice Agent API", "Flux", "TTS"], whitespace: "", projectId: "", balanceId: "", startDate: "6/26/25", contractEndDate: "6/26/26", startingCredits: 41000, creditsRemaining: 12945, isHosted: false, concurrencyLimit: 200, currentConcurrency: 0, peak24h: 0, peak7d: 0, peak30d: 0, peak90d: 0, peakAll: 0, notes: "self hosted" },
            { name: "CareCo", location: "PA, US", useCase: "Ambient Scribe", products: ["Batch STT"], whitespace: "Medical, Language Expansion", projectId: "", balanceId: "", startDate: "2/10/25", contractEndDate: "2/10/26", startingCredits: 15000, creditsRemaining: 3124, isHosted: true, concurrencyLimit: 25, currentConcurrency: 18, peak24h: 23, peak7d: 24, peak30d: 25, peak90d: 25, peakAll: 25, notes: "" },
            { name: "Authenticx", location: "Indianapolis", useCase: "Healthcare QA", products: ["Batch STT"], whitespace: "Medical, Language Expansion", projectId: "", balanceId: "", startDate: "4/1/24", contractEndDate: "4/1/26", startingCredits: 479000, creditsRemaining: 231751, isHosted: true, concurrencyLimit: 150, currentConcurrency: 112, peak24h: 140, peak7d: 145, peak30d: 148, peak90d: 150, peakAll: 150, notes: "nova-2-ea" },
            { name: "Berribot", location: "Singapore", useCase: "Voice Agent / Recruiting", products: ["Realtime STT", "Voice Agent API", "Flux", "TTS"], whitespace: "", projectId: "", balanceId: "", startDate: "8/29/25", contractEndDate: "8/29/26", startingCredits: 10500, creditsRemaining: 7353, isHosted: false, concurrencyLimit: 75, currentConcurrency: 0, peak24h: 0, peak7d: 0, peak30d: 0, peak90d: 0, peakAll: 0, notes: "self hosted flux" },
            { name: "Checkmate", location: "NY, NY", useCase: "Drive Thru AI", products: ["Realtime STT", "Voice Agent API", "Flux"], whitespace: "", projectId: "", balanceId: "", startDate: "3/21/25", contractEndDate: "3/21/26", startingCredits: 10000, creditsRemaining: 5161, isHosted: true, concurrencyLimit: 30, currentConcurrency: 22, peak24h: 28, peak7d: 29, peak30d: 30, peak90d: 30, peakAll: 30, notes: "custom model" },
            { name: "Veed", location: "UK", useCase: "Video Tx", products: ["Batch STT", "Language Expansion"], whitespace: "", projectId: "", balanceId: "", startDate: "12/22/24", contractEndDate: "12/22/25", startingCredits: 8000, creditsRemaining: 4800, isHosted: true, concurrencyLimit: 20, currentConcurrency: 12, peak24h: 18, peak7d: 19, peak30d: 20, peak90d: 20, peakAll: 20, notes: "" },
            { name: "Toma", location: "NY, NY", useCase: "Voice Agent (automotive)", products: ["Realtime STT", "Voice Agent API", "Flux", "TTS"], whitespace: "", projectId: "", balanceId: "", startDate: "9/19/25", contractEndDate: "9/19/26", startingCredits: 20277, creditsRemaining: 14471, isHosted: true, concurrencyLimit: 60, currentConcurrency: 45, peak24h: 58, peak7d: 59, peak30d: 60, peak90d: 60, peakAll: 60, notes: "" },
            { name: "33n", location: "CA", useCase: "Ambient Scribe", products: ["Batch STT"], whitespace: "Medical, Language Expansion", projectId: "", balanceId: "", startDate: "5/2/25", contractEndDate: "5/2/26", startingCredits: 24000, creditsRemaining: 18000, isHosted: true, concurrencyLimit: 40, currentConcurrency: 28, peak24h: 38, peak7d: 39, peak30d: 40, peak90d: 40, peakAll: 40, notes: "" },
            { name: "Kustomer", location: "New Jersey", useCase: "CX", products: ["Batch STT", "Voice Agent API"], whitespace: "", projectId: "", balanceId: "", startDate: "6/30/25", contractEndDate: "6/30/26", startingCredits: 33586, creditsRemaining: 26610, isHosted: true, concurrencyLimit: 50, currentConcurrency: 38, peak24h: 48, peak7d: 49, peak30d: 50, peak90d: 50, peakAll: 50, notes: "" },
            { name: "Inceptia", location: "Argentina", useCase: "Voice Agent", products: ["Realtime STT", "Voice Agent API", "Language Expansion", "Flux"], whitespace: "", projectId: "", balanceId: "", startDate: "4/18/25", contractEndDate: "4/18/26", startingCredits: 88333, creditsRemaining: 73070, isHosted: true, concurrencyLimit: 80, currentConcurrency: 65, peak24h: 76, peak7d: 78, peak30d: 80, peak90d: 80, peakAll: 80, notes: "" },
            { name: "Kindroid", location: "LA, CA", useCase: "Voice Agent / Entertainment", products: ["Realtime STT", "Flux"], whitespace: "", projectId: "", balanceId: "", startDate: "2/5/25", contractEndDate: "2/5/26", startingCredits: 19000, creditsRemaining: 16377, isHosted: true, concurrencyLimit: 35, currentConcurrency: 28, peak24h: 33, peak7d: 34, peak30d: 35, peak90d: 35, peakAll: 35, notes: "" },
            { name: "iScribe Health", location: "Nashville, TN", useCase: "Ambient Medical", products: ["Batch STT", "Medical", "Language Expansion"], whitespace: "", projectId: "", balanceId: "", startDate: "7/25/25", contractEndDate: "7/25/26", startingCredits: 166000, creditsRemaining: 146388, isHosted: true, concurrencyLimit: 120, currentConcurrency: 95, peak24h: 115, peak7d: 118, peak30d: 120, peak90d: 120, peakAll: 120, notes: "" },
            { name: "Mercor", location: "San Francisco", useCase: "Voice Agent / Recruiting", products: ["Realtime STT", "Voice Agent API", "Flux", "TTS"], whitespace: "", projectId: "", balanceId: "", startDate: "10/1/25", contractEndDate: "10/1/26", startingCredits: 68731, creditsRemaining: 61253, isHosted: true, concurrencyLimit: 70, currentConcurrency: 55, peak24h: 68, peak7d: 69, peak30d: 70, peak90d: 70, peakAll: 70, notes: "" },
            { name: "ContactUs", location: "Ohio", useCase: "CX", products: ["Batch STT"], whitespace: "", projectId: "", balanceId: "", startDate: "3/30/25", contractEndDate: "3/30/26", startingCredits: 10000, creditsRemaining: 9129, isHosted: true, concurrencyLimit: 25, currentConcurrency: 20, peak24h: 24, peak7d: 24, peak30d: 25, peak90d: 25, peakAll: 25, notes: "" },
            { name: "IDEXX", location: "Maine", useCase: "Ambient Medical", products: ["Batch STT", "Medical"], whitespace: "", projectId: "", balanceId: "", startDate: "7/28/25", contractEndDate: "7/28/26", startingCredits: 55540, creditsRemaining: 50826, isHosted: true, concurrencyLimit: 60, currentConcurrency: 48, peak24h: 58, peak7d: 59, peak30d: 60, peak90d: 60, peakAll: 60, notes: "" },
            { name: "Because Mkt", location: "CA", useCase: "Internal CX", products: ["Batch STT", "Voice Agent API"], whitespace: "", projectId: "", balanceId: "", startDate: "8/29/25", contractEndDate: "8/29/26", startingCredits: 15000, creditsRemaining: 14323, isHosted: true, concurrencyLimit: 30, currentConcurrency: 25, peak24h: 29, peak7d: 30, peak30d: 30, peak90d: 30, peakAll: 30, notes: "" },
            { name: "Asurion", location: "Nashville, TN", useCase: "Customer Service", products: ["Realtime STT"], whitespace: "", projectId: "", balanceId: "", startDate: "1/1/25", contractEndDate: "1/1/28", startingCredits: 1074736, creditsRemaining: 1058000, isHosted: true, concurrencyLimit: 500, currentConcurrency: 420, peak24h: 485, peak7d: 495, peak30d: 500, peak90d: 500, peakAll: 500, notes: "" },
            { name: "Voxy", location: "Miami, FL", useCase: "CX", products: ["Realtime STT", "Language Expansion", "Flux"], whitespace: "", projectId: "", balanceId: "", startDate: "9/1/25", contractEndDate: "9/1/26", startingCredits: 83800, creditsRemaining: 82800, isHosted: true, concurrencyLimit: 75, currentConcurrency: 60, peak24h: 72, peak7d: 74, peak30d: 75, peak90d: 75, peakAll: 75, notes: "" },
            { name: "Phenom", location: "PA, US", useCase: "Voice Agent / Recruiting", products: ["Realtime STT", "Voice Agent API", "Flux", "TTS"], whitespace: "", projectId: "", balanceId: "", startDate: "8/21/25", contractEndDate: "8/21/26", startingCredits: 14550, creditsRemaining: 14443, isHosted: true, concurrencyLimit: 35, currentConcurrency: 28, peak24h: 34, peak7d: 35, peak30d: 35, peak90d: 35, peakAll: 35, notes: "" },
            { name: "Spearfish", location: "Ohio", useCase: "CX", products: ["Batch STT"], whitespace: "", projectId: "", balanceId: "", startDate: "9/19/25", contractEndDate: "9/19/26", startingCredits: 50000, creditsRemaining: 49908, isHosted: true, concurrencyLimit: 55, currentConcurrency: 42, peak24h: 53, peak7d: 54, peak30d: 55, peak90d: 55, peakAll: 55, notes: "" },
            { name: "Chegg", location: "Santa Clara, CA", useCase: "Voice Agent / tutor", products: ["Realtime STT", "Voice Agent API", "Flux", "TTS"], whitespace: "", projectId: "", balanceId: "", startDate: "8/21/25", contractEndDate: "8/21/26", startingCredits: 24000, creditsRemaining: 23979, isHosted: true, concurrencyLimit: 45, currentConcurrency: 35, peak24h: 43, peak7d: 44, peak30d: 45, peak90d: 45, peakAll: 45, notes: "" },
            { name: "Yung", location: "Miami, FL", useCase: "Therapy notes", products: ["Batch STT"], whitespace: "", projectId: "", balanceId: "", startDate: "10/16/24", contractEndDate: "10/16/25", startingCredits: 15820, creditsRemaining: 15820, isHosted: true, concurrencyLimit: 30, currentConcurrency: 5, peak24h: 8, peak7d: 10, peak30d: 12, peak90d: 15, peakAll: 18, notes: "" },
            { name: "Talkative", location: "UK", useCase: "CX Video call", products: ["Realtime STT", "Voice Agent API", "Flux", "TTS"], whitespace: "", projectId: "", balanceId: "", startDate: "9/29/25", contractEndDate: "9/29/26", startingCredits: 32400, creditsRemaining: 32400, isHosted: true, concurrencyLimit: 50, currentConcurrency: 12, peak24h: 18, peak7d: 22, peak30d: 28, peak90d: 35, peakAll: 42, notes: "" },
            { name: "Ninja Notes", location: "Texas", useCase: "Ambient Scribe", products: ["Batch STT"], whitespace: "", projectId: "", balanceId: "", startDate: "7/18/25", contractEndDate: "7/18/27", startingCredits: 40000, creditsRemaining: 40000, isHosted: true, concurrencyLimit: 55, currentConcurrency: 15, peak24h: 22, peak7d: 28, peak30d: 35, peak90d: 42, peakAll: 48, notes: "24 month" },
            { name: "ITEC", location: "Colorado", useCase: "Medical Translation", products: ["Realtime STT", "Flux", "Language Expansion", "Medical"], whitespace: "", projectId: "", balanceId: "", startDate: "10/7/25", contractEndDate: "10/7/26", startingCredits: 105000, creditsRemaining: 105000, isHosted: true, concurrencyLimit: 90, currentConcurrency: 25, peak24h: 35, peak7d: 42, peak30d: 55, peak90d: 68, peakAll: 75, notes: "Making new model" }
        ];
        
        let customers = [];
        let prospects = [];
        let sortColumn = null;
        let sortDirection = 'asc';
        let peakPeriod = '24h';
        
        // Load from localStorage or use original data
        function loadData() {
            const saved = localStorage.getItem('deepgramCustomers');
            if (saved) {
                try {
                    customers = JSON.parse(saved);
                } catch (e) {
                    customers = [...originalCustomers];
                }
            } else {
                customers = [...originalCustomers];
            }
            
            const savedProspects = localStorage.getItem('deepgramProspects');
            if (savedProspects) {
                try {
                    prospects = JSON.parse(savedProspects);
                } catch (e) {
                    prospects = [];
                }
            }
        }
        
        function saveData() {
            localStorage.setItem('deepgramCustomers', JSON.stringify(customers));
            showSaveIndicator();
        }
        
        function saveProspects() {
            localStorage.setItem('deepgramProspects', JSON.stringify(prospects));
            showSaveIndicator();
        }
        
        function showSaveIndicator() {
            const indicator = document.getElementById('saveIndicator');
            indicator.style.display = 'block';
            setTimeout(() => {
                indicator.style.display = 'none';
            }, 2000);
        }
        
        function makeEditable(cell, customerIndex, field) {
            if (cell.querySelector('input') || cell.querySelector('textarea')) return;
            
            const currentValue = customers[customerIndex][field];
            const isNumber = field === 'startingCredits' || field === 'creditsRemaining';
            const isLongText = field === 'notes';
            
            cell.classList.add('editing');
            
            let input;
            if (isLongText) {
                input = document.createElement('textarea');
                input.className = 'edit-textarea';
            } else {
                input = document.createElement('input');
                input.className = 'edit-input';
                if (isNumber) input.type = 'number';
            }
            
            input.value = currentValue || '';
            
            const originalContent = cell.innerHTML;
            cell.innerHTML = '';
            cell.appendChild(input);
            input.focus();
            if (!isLongText) input.select();
            
            function saveEdit() {
                let newValue = input.value;
                if (isNumber) {
                    newValue = parseFloat(newValue) || 0;
                }
                customers[customerIndex][field] = newValue;
                saveData();
                renderTable();
                updateStats();
            }
            
            function cancelEdit() {
                cell.innerHTML = originalContent;
                cell.classList.remove('editing');
            }
            
            input.addEventListener('blur', saveEdit);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    saveEdit();
                } else if (e.key === 'Escape') {
                    cancelEdit();
                }
            });
        }
        
        function deleteCustomer(index) {
            if (confirm(`Delete ${customers[index].name}?`)) {
                customers.splice(index, 1);
                saveData();
                renderTable();
                updateStats();
            }
        }
        
        function addNewCustomer() {
            const today = new Date();
            const endDate = new Date(today);
            endDate.setFullYear(endDate.getFullYear() + 1);
            
            const newCustomer = {
                name: "New Customer",
                location: "",
                useCase: "Voice Agent",
                products: ["Batch STT"],
                whitespace: "",
                projectId: "",
                balanceId: "",
                startDate: today.toLocaleDateString('en-US', { month: 'numeric', day: 'numeric', year: '2-digit' }),
                contractEndDate: endDate.toLocaleDateString('en-US', { month: 'numeric', day: 'numeric', year: '2-digit' }),
                startingCredits: 10000,
                creditsRemaining: 10000,
                isHosted: true,
                concurrencyLimit: 50,
                currentConcurrency: 0,
                peak24h: 0,
                peak7d: 0,
                peak30d: 0,
                peak90d: 0,
                peakAll: 0,
                notes: ""
            };
            customers.unshift(newCustomer);
            saveData();
            renderTable();
            updateStats();
        }
        
        function updatePeakPeriod(period) {
            peakPeriod = period;
            const headerText = {
                '24h': 'Peak (24h)',
                '7d': 'Peak (7d)',
                '30d': 'Peak (30d)',
                '90d': 'Peak (90d)',
                'all': 'Peak (All)'
            };
            document.getElementById('peakHeader').innerHTML = headerText[period] + ' <span style="color: #ccc; font-size: 9px;">‚áÖ</span>';
            renderConcurrencyTables();
            initConcurrencyChart();
        }
        
        function getPeakValue(customer) {
            const periodMap = {
                '24h': 'peak24h',
                '7d': 'peak7d',
                '30d': 'peak30d',
                '90d': 'peak90d',
                'all': 'peakAll'
            };
            const field = periodMap[peakPeriod];
            return customer[field] || customer.peakConcurrency || 0;
        }
        
        function addNewProspect() {
            const newProspect = {
                name: "New Prospect",
                location: "",
                useCase: "Voice Agent",
                products: ["Batch STT"],
                stage: "Discovery",
                estimatedValue: 10000,
                probability: 50,
                expectedClose: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toLocaleDateString('en-US', { month: 'numeric', day: 'numeric', year: '2-digit' }),
                lastContact: new Date().toLocaleDateString('en-US', { month: 'numeric', day: 'numeric', year: '2-digit' }),
                notes: ""
            };
            prospects.unshift(newProspect);
            saveProspects();
            renderProspectTable();
        }
        
        function deleteProspect(index) {
            if (confirm(`Delete ${prospects[index].name}?`)) {
                prospects.splice(index, 1);
                saveProspects();
                renderProspectTable();
            }
        }
        
        function convertToCustomer(index) {
            if (confirm(`Convert ${prospects[index].name} to customer?`)) {
                const prospect = prospects[index];
                const newCustomer = {
                    name: prospect.name,
                    location: prospect.location,
                    useCase: prospect.useCase,
                    products: prospect.products,
                    whitespace: "",
                    projectId: "",
                    balanceId: "",
                    startDate: new Date().toLocaleDateString('en-US', { month: 'numeric', day: 'numeric', year: '2-digit' }),
                    contractLength: 1,
                    startingCredits: prospect.estimatedValue,
                    creditsRemaining: prospect.estimatedValue,
                    notes: prospect.notes
                };
                customers.unshift(newCustomer);
                prospects.splice(index, 1);
                saveData();
                saveProspects();
                renderProspectTable();
                alert(`${prospect.name} converted to customer! Switch to Customers tab to see them.`);
            }
        }
        
        // Check if renewal is within 4 months
        function isApproachingRenewal(contractEndDate) {
            if (!contractEndDate) return false;
            
            const endDate = new Date(contractEndDate);
            if (isNaN(endDate.getTime())) return false;
            
            const today = new Date();
            const fourMonthsFromNow = new Date();
            fourMonthsFromNow.setMonth(fourMonthsFromNow.getMonth() + 4);
            
            return endDate <= fourMonthsFromNow && endDate >= today;
        }
        
        // API Key Management
        function showApiKeyModal() {
            const modal = document.getElementById('apiKeyModal');
            const input = document.getElementById('apiKeyInput');
            const existingKey = localStorage.getItem('deepgramApiKey');
            if (existingKey) {
                input.value = existingKey;
            }
            modal.style.display = 'block';
        }
        
        function closeApiKeyModal() {
            document.getElementById('apiKeyModal').style.display = 'none';
        }
        
        function saveApiKey() {
            const apiKey = document.getElementById('apiKeyInput').value.trim();
            if (apiKey) {
                localStorage.setItem('deepgramApiKey', apiKey);
                showSaveIndicator();
                closeApiKeyModal();
                alert('API Key saved successfully! You can now refresh balances from Deepgram.');
            } else {
                alert('Please enter a valid API key.');
            }
        }
        
        // Fetch balance from Deepgram API
        async function fetchBalance(projectId, balanceId, customerIndex) {
            const apiKey = localStorage.getItem('deepgramApiKey');
            if (!apiKey) {
                alert('Please set your Deepgram API key first (click üîë Set API Key)');
                return null;
            }
            
            if (!projectId || !balanceId) {
                return null;
            }
            
            try {
                const url = `https://api.deepgram.com/v1/projects/${projectId}/balances/${balanceId}`;
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Token ${apiKey}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`API Error: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Error fetching balance:', error);
                return { error: error.message };
            }
        }
        
        async function refreshBalance(customerIndex) {
            const customer = customers[customerIndex];
            
            if (!customer.projectId || !customer.balanceId) {
                alert(`Please add Project ID and Balance ID for ${customer.name} first (click to edit the cells)`);
                return;
            }
            
            // Show loading indicator
            const row = document.querySelectorAll('#customerTableBody tr')[customerIndex];
            if (row) {
                const actionsCell = row.querySelector('td:last-child');
                const originalHtml = actionsCell.innerHTML;
                actionsCell.innerHTML += '<span class="api-status api-loading">Loading...</span>';
                
                const balanceData = await fetchBalance(customer.projectId, customer.balanceId, customerIndex);
                
                if (balanceData && !balanceData.error) {
                    // Update credits remaining with the API data
                    customers[customerIndex].creditsRemaining = balanceData.amount || 0;
                    saveData();
                    renderTable();
                    updateStats();
                    actionsCell.innerHTML = originalHtml + '<span class="api-status api-success">‚úì Updated</span>';
                    setTimeout(() => {
                        renderTable();
                    }, 2000);
                } else {
                    actionsCell.innerHTML = originalHtml + `<span class="api-status api-error">Error: ${balanceData?.error || 'Failed'}</span>`;
                    setTimeout(() => {
                        renderTable();
                    }, 3000);
                }
            }
        }
        
        async function refreshAllBalances() {
            const apiKey = localStorage.getItem('deepgramApiKey');
            if (!apiKey) {
                alert('Please set your Deepgram API key first (click üîë Set API Key)');
                return;
            }
            
            const customersWithIds = customers.filter(c => c.projectId && c.balanceId);
            
            if (customersWithIds.length === 0) {
                alert('No customers have both Project ID and Balance ID set. Please add these IDs first by clicking on the cells.');
                return;
            }
            
            if (!confirm(`Refresh balances for ${customersWithIds.length} customer(s)?`)) {
                return;
            }
            
            let successCount = 0;
            let errorCount = 0;
            
            for (let i = 0; i < customers.length; i++) {
                const customer = customers[i];
                if (customer.projectId && customer.balanceId) {
                    const balanceData = await fetchBalance(customer.projectId, customer.balanceId, i);
                    if (balanceData && !balanceData.error) {
                        customers[i].creditsRemaining = balanceData.amount || 0;
                        successCount++;
                    } else {
                        errorCount++;
                    }
                }
            }
            
            saveData();
            renderTable();
            updateStats();
            
            alert(`Balance refresh complete!\n‚úì Success: ${successCount}\n‚úó Errors: ${errorCount}`);
        }
        
        function resetData() {
            if (confirm('Reset all data to original values? This will delete any changes you made.')) {
                localStorage.removeItem('deepgramCustomers');
                loadData();
                renderTable();
                updateStats();
                showSaveIndicator();
            }
        }
        
        function sortTable(column) {
            // Toggle sort direction if clicking the same column
            if (sortColumn === column) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortColumn = column;
                sortDirection = 'asc';
            }
            
            customers.sort((a, b) => {
                let aVal = a[column];
                let bVal = b[column];
                
                // Special handling for percentage
                if (column === 'percentage') {
                    aVal = (a.creditsRemaining / a.startingCredits) * 100;
                    bVal = (b.creditsRemaining / b.startingCredits) * 100;
                }
                
                // Handle numbers
                if (column === 'startingCredits' || column === 'creditsRemaining' || column === 'percentage') {
                    aVal = parseFloat(aVal) || 0;
                    bVal = parseFloat(bVal) || 0;
                }
                
                // Handle dates
                if (column === 'startDate') {
                    aVal = new Date(aVal);
                    bVal = new Date(bVal);
                }
                
                // Handle strings (case insensitive)
                if (typeof aVal === 'string') {
                    aVal = aVal.toLowerCase();
                    bVal = (bVal || '').toLowerCase();
                }
                
                let comparison = 0;
                if (aVal > bVal) comparison = 1;
                if (aVal < bVal) comparison = -1;
                
                return sortDirection === 'asc' ? comparison : -comparison;
            });
            
            renderTable();
            updateSortIndicators();
        }
        
        function updateSortIndicators() {
            // Remove all sort classes
            document.querySelectorAll('th').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
            });
            
            // Add sort class to active column
            if (sortColumn) {
                const th = document.querySelector(`th[data-sort="${sortColumn}"]`);
                if (th) {
                    th.classList.add(sortDirection === 'asc' ? 'sort-asc' : 'sort-desc');
                }
            }
        }
        
        function renderTable() {
            const tbody = document.getElementById('customerTableBody');
            tbody.innerHTML = '';
            
            customers.forEach((c, index) => {
                const pct = (c.creditsRemaining / c.startingCredits) * 100;
                let statusClass = 'status-green';
                if (pct < 25) statusClass = 'status-red';
                else if (pct < 50) statusClass = 'status-yellow';
                
                const productsHtml = c.products.map(p => {
                    let tagClass = 'tag-batch';
                    if (p.includes('Realtime')) tagClass = 'tag-realtime';
                    else if (p.includes('Voice')) tagClass = 'tag-voice';
                    else if (p.includes('Flux')) tagClass = 'tag-flux';
                    else if (p.includes('Medical')) tagClass = 'tag-medical';
                    else if (p.includes('TTS')) tagClass = 'tag-tts';
                    else if (p.includes('Language')) tagClass = 'tag-language';
                    return `<span class="product-tag ${tagClass}">${p}</span>`;
                }).join('');
                
                const approachingRenewal = isApproachingRenewal(c.contractEndDate);
                
                const row = document.createElement('tr');
                if (approachingRenewal) {
                    row.className = 'renewal-warning';
                }
                
                row.innerHTML = `
                    <td class="editable compact-cell" title="${c.name}"><strong>${c.name}</strong>${approachingRenewal ? '<span class="renewal-badge">RNWL</span>' : ''}</td>
                    <td class="editable compact-cell" title="${c.location}">${c.location}</td>
                    <td class="editable compact-cell" title="${c.useCase}">${c.useCase}</td>
                    <td class="narrow-cell">${productsHtml}</td>
                    <td class="editable compact-cell" title="${c.whitespace}">${c.whitespace || '-'}</td>
                    <td class="editable compact-cell" style="font-size: 9px; font-family: monospace;" title="${c.projectId}">${c.projectId ? c.projectId.substring(0, 10) + '...' : '-'}</td>
                    <td class="editable compact-cell" style="font-size: 9px; font-family: monospace;" title="${c.balanceId}">${c.balanceId ? c.balanceId.substring(0, 10) + '...' : '-'}</td>
                    <td class="editable narrow-cell">${c.startDate}</td>
                    <td class="editable narrow-cell" style="font-weight: ${approachingRenewal ? '700' : '400'}; color: ${approachingRenewal ? '#FFA500' : 'inherit'};">${c.contractEndDate || '-'}</td>
                    <td class="editable currency compact-cell">$${(c.startingCredits / 1000).toFixed(0)}k</td>
                    <td class="editable currency compact-cell">$${(c.creditsRemaining / 1000).toFixed(0)}k</td>
                    <td class="narrow-cell"><div class="percentage-cell ${statusClass}">${pct.toFixed(0)}%</div></td>
                    <td class="editable compact-cell" title="${c.notes}">${c.notes || '-'}</td>
                    <td class="narrow-cell" style="white-space: nowrap;">
                        <button class="action-btn" onclick="refreshBalance(${index})" title="Refresh">üîÑ</button>
                        <button class="action-btn" onclick="deleteCustomer(${index})" title="Delete">üóëÔ∏è</button>
                    </td>
                `;
                
                // Add click handlers for editable cells
                const editableCells = row.querySelectorAll('.editable');
                const fields = ['name', 'location', 'useCase', 'whitespace', 'projectId', 'balanceId', 'startDate', 'contractEndDate', 'startingCredits', 'creditsRemaining', 'notes'];
                editableCells.forEach((cell, cellIndex) => {
                    if (cellIndex < fields.length) {
                        cell.addEventListener('click', () => makeEditable(cell, index, fields[cellIndex]));
                    }
                });
                
                tbody.appendChild(row);
            });
        }
        
        function updateStats() {
            document.getElementById('totalCustomers').textContent = customers.length;
            
            const totalContracted = customers.reduce((sum, c) => sum + c.startingCredits, 0);
            document.getElementById('totalContracted').textContent = '$' + (totalContracted / 1000000).toFixed(2) + 'M';
            
            const totalRemaining = customers.reduce((sum, c) => sum + c.creditsRemaining, 0);
            document.getElementById('totalRemaining').textContent = '$' + (totalRemaining / 1000000).toFixed(2) + 'M';
            
            const atRisk = customers.filter(c => {
                const pct = (c.creditsRemaining / c.startingCredits) * 100;
                return pct < 25;
            }).length;
            document.getElementById('atRiskCount').textContent = atRisk;
        }
        
        function exportToCSV() {
            let csv = 'Customer,Location,Use Case,Products,Whitespace,Start Date,Starting Credits,Credits Remaining,Percentage,Notes\\n';
            
            customers.forEach(c => {
                const percentage = ((c.creditsRemaining / c.startingCredits) * 100).toFixed(2);
                const products = c.products.join('; ');
                csv += `"${c.name}","${c.location}","${c.useCase}","${products}","${c.whitespace}","${c.startDate}",${c.startingCredits},${c.creditsRemaining},${percentage},"${c.notes}"\\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `deepgram-dashboard-${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
        }
        
        // Prospect table rendering
        function renderProspectTable() {
            const tbody = document.getElementById('prospectTableBody');
            tbody.innerHTML = '';
            
            if (prospects.length === 0) {
                tbody.innerHTML = '<tr><td colspan="11" style="text-align: center; padding: 40px; color: #999;">No prospects yet. Click "üéØ Add Prospect" to start tracking opportunities.</td></tr>';
                return;
            }
            
            prospects.forEach((p, index) => {
                const productsHtml = p.products.map(prod => {
                    let tagClass = 'tag-batch';
                    if (prod.includes('Realtime')) tagClass = 'tag-realtime';
                    else if (prod.includes('Voice')) tagClass = 'tag-voice';
                    else if (prod.includes('Flux')) tagClass = 'tag-flux';
                    else if (prod.includes('Medical')) tagClass = 'tag-medical';
                    else if (prod.includes('TTS')) tagClass = 'tag-tts';
                    else if (prod.includes('Language')) tagClass = 'tag-language';
                    return `<span class="product-tag ${tagClass}">${prod}</span>`;
                }).join('');
                
                let stageColor = '#666';
                if (p.stage === 'Closed Won') stageColor = '#28a745';
                else if (p.stage === 'Negotiation') stageColor = '#ffc107';
                else if (p.stage === 'Discovery') stageColor = '#17a2b8';
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td class="editable compact-cell" title="${p.name}"><strong>${p.name}</strong></td>
                    <td class="editable compact-cell" title="${p.location}">${p.location || '-'}</td>
                    <td class="editable compact-cell" title="${p.useCase}">${p.useCase}</td>
                    <td class="narrow-cell">${productsHtml}</td>
                    <td class="narrow-cell">
                        <select class="contract-select" onchange="updateProspectField(${index}, 'stage', this.value)" style="color: ${stageColor};">
                            <option value="Lead" ${p.stage === 'Lead' ? 'selected' : ''}>Lead</option>
                            <option value="Discovery" ${p.stage === 'Discovery' ? 'selected' : ''}>Discovery</option>
                            <option value="Demo" ${p.stage === 'Demo' ? 'selected' : ''}>Demo</option>
                            <option value="Proposal" ${p.stage === 'Proposal' ? 'selected' : ''}>Proposal</option>
                            <option value="Negotiation" ${p.stage === 'Negotiation' ? 'selected' : ''}>Negotiation</option>
                            <option value="Closed Won" ${p.stage === 'Closed Won' ? 'selected' : ''}>Won</option>
                            <option value="Closed Lost" ${p.stage === 'Closed Lost' ? 'selected' : ''}>Lost</option>
                        </select>
                    </td>
                    <td class="editable currency compact-cell">$${((p.estimatedValue || 0) / 1000).toFixed(0)}k</td>
                    <td class="editable narrow-cell">${p.probability || 0}%</td>
                    <td class="editable narrow-cell">${p.expectedClose || '-'}</td>
                    <td class="editable narrow-cell">${p.lastContact || '-'}</td>
                    <td class="editable compact-cell" title="${p.notes}">${p.notes || '-'}</td>
                    <td class="narrow-cell" style="white-space: nowrap;">
                        <button class="action-btn" onclick="convertToCustomer(${index})" title="Convert">‚úÖ</button>
                        <button class="action-btn" onclick="deleteProspect(${index})" title="Delete">üóëÔ∏è</button>
                    </td>
                `;
                
                // Add click handlers for editable cells
                const editableCells = row.querySelectorAll('.editable');
                const fields = ['name', 'location', 'useCase', 'estimatedValue', 'probability', 'expectedClose', 'lastContact', 'notes'];
                editableCells.forEach((cell, cellIndex) => {
                    if (cellIndex < fields.length) {
                        cell.addEventListener('click', () => makeProspectEditable(cell, index, fields[cellIndex]));
                    }
                });
                
                tbody.appendChild(row);
            });
        }
        
        function makeProspectEditable(cell, prospectIndex, field) {
            if (cell.querySelector('input') || cell.querySelector('textarea')) return;
            
            const currentValue = prospects[prospectIndex][field];
            const isNumber = field === 'estimatedValue' || field === 'probability';
            const isLongText = field === 'notes';
            
            cell.classList.add('editing');
            
            let input;
            if (isLongText) {
                input = document.createElement('textarea');
                input.className = 'edit-textarea';
            } else {
                input = document.createElement('input');
                input.className = 'edit-input';
                if (isNumber) input.type = 'number';
            }
            
            input.value = currentValue || '';
            
            const originalContent = cell.innerHTML;
            cell.innerHTML = '';
            cell.appendChild(input);
            input.focus();
            if (!isLongText) input.select();
            
            function saveEdit() {
                let newValue = input.value;
                if (isNumber) {
                    newValue = parseFloat(newValue) || 0;
                }
                prospects[prospectIndex][field] = newValue;
                saveProspects();
                renderProspectTable();
            }
            
            function cancelEdit() {
                cell.innerHTML = originalContent;
                cell.classList.remove('editing');
            }
            
            input.addEventListener('blur', saveEdit);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    saveEdit();
                } else if (e.key === 'Escape') {
                    cancelEdit();
                }
            });
        }
        
        function updateProspectField(index, field, value) {
            prospects[index][field] = value;
            saveProspects();
            renderProspectTable();
        }
        
        // Concurrency tracking
        function renderConcurrencyTables() {
            renderHostedConcurrency();
            renderSelfHostedConcurrency();
        }
        
        function renderHostedConcurrency() {
            const tbody = document.getElementById('hostedConcurrencyTableBody');
            tbody.innerHTML = '';
            
            const hostedCustomers = customers.filter(c => c.isHosted !== false);
            
            if (hostedCustomers.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; padding: 40px; color: #999;">No hosted customers</td></tr>';
                return;
            }
            
            hostedCustomers.forEach((c, index) => {
                const actualIndex = customers.indexOf(c);
                const peakValue = getPeakValue(c);
                const utilizationPct = (peakValue / (c.concurrencyLimit || 1)) * 100;
                let statusClass = 'status-green';
                if (utilizationPct >= 90) statusClass = 'status-red';
                else if (utilizationPct >= 75) statusClass = 'status-yellow';
                
                const productsHtml = c.products.map(p => {
                    let tagClass = 'tag-batch';
                    if (p.includes('Realtime')) tagClass = 'tag-realtime';
                    else if (p.includes('Voice')) tagClass = 'tag-voice';
                    else if (p.includes('Flux')) tagClass = 'tag-flux';
                    return `<span class="product-tag ${tagClass}">${p}</span>`;
                }).join('');
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td class="compact-cell" title="${c.name}"><strong>${c.name}</strong></td>
                    <td class="editable narrow-cell">${c.concurrencyLimit || 0}</td>
                    <td class="editable narrow-cell">${c.currentConcurrency || 0}</td>
                    <td class="editable narrow-cell">${peakValue}</td>
                    <td class="narrow-cell"><div class="percentage-cell ${statusClass}">${utilizationPct.toFixed(0)}%</div></td>
                    <td class="narrow-cell">${productsHtml}</td>
                    <td class="compact-cell editable" title="${c.notes}">${c.notes || '-'}</td>
                    <td class="narrow-cell">
                        <button class="action-btn" onclick="alert('Concurrency details for ${c.name}')" title="Details">üìä</button>
                    </td>
                `;
                
                // Add editable handlers
                const editableCells = row.querySelectorAll('.editable');
                const periodMap = {
                    '24h': 'peak24h',
                    '7d': 'peak7d',
                    '30d': 'peak30d',
                    '90d': 'peak90d',
                    'all': 'peakAll'
                };
                const peakField = periodMap[peakPeriod] || 'peak24h';
                const fields = ['concurrencyLimit', 'currentConcurrency', peakField, 'notes'];
                editableCells.forEach((cell, cellIndex) => {
                    if (cellIndex < fields.length) {
                        cell.addEventListener('click', () => makeConcurrencyEditable(cell, actualIndex, fields[cellIndex]));
                    }
                });
                
                tbody.appendChild(row);
            });
        }
        
        function renderSelfHostedConcurrency() {
            const tbody = document.getElementById('selfHostedConcurrencyTableBody');
            tbody.innerHTML = '';
            
            const selfHostedCustomers = customers.filter(c => c.isHosted === false);
            
            if (selfHostedCustomers.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; padding: 40px; color: #999;">No self-hosted customers</td></tr>';
                return;
            }
            
            selfHostedCustomers.forEach((c) => {
                const actualIndex = customers.indexOf(c);
                const productsHtml = c.products.map(p => {
                    let tagClass = 'tag-batch';
                    if (p.includes('Realtime')) tagClass = 'tag-realtime';
                    else if (p.includes('Voice')) tagClass = 'tag-voice';
                    else if (p.includes('Flux')) tagClass = 'tag-flux';
                    return `<span class="product-tag ${tagClass}">${p}</span>`;
                }).join('');
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td class="compact-cell" title="${c.name}"><strong>${c.name}</strong></td>
                    <td class="editable narrow-cell">${c.concurrencyLimit || 0}</td>
                    <td class="narrow-cell">${productsHtml}</td>
                    <td class="compact-cell editable" title="${c.notes}">${c.notes || '-'}</td>
                    <td class="narrow-cell">
                        <button class="action-btn" onclick="alert('Self-hosted - no usage tracking')" title="Info">‚ÑπÔ∏è</button>
                    </td>
                `;
                
                // Add editable handlers
                const editableCells = row.querySelectorAll('.editable');
                const fields = ['concurrencyLimit', 'notes'];
                editableCells.forEach((cell, cellIndex) => {
                    if (cellIndex < fields.length) {
                        cell.addEventListener('click', () => makeConcurrencyEditable(cell, actualIndex, fields[cellIndex]));
                    }
                });
                
                tbody.appendChild(row);
            });
        }
        
        function makeConcurrencyEditable(cell, customerIndex, field) {
            if (cell.querySelector('input')) return;
            
            const currentValue = customers[customerIndex][field];
            const isNumber = field !== 'notes';
            
            cell.classList.add('editing');
            
            const input = document.createElement('input');
            input.className = 'edit-input';
            if (isNumber) input.type = 'number';
            input.value = currentValue || '';
            
            const originalContent = cell.innerHTML;
            cell.innerHTML = '';
            cell.appendChild(input);
            input.focus();
            input.select();
            
            function saveEdit() {
                let newValue = input.value;
                if (isNumber) {
                    newValue = parseInt(newValue) || 0;
                }
                customers[customerIndex][field] = newValue;
                saveData();
                renderConcurrencyTables();
                initConcurrencyChart();
            }
            
            function cancelEdit() {
                cell.innerHTML = originalContent;
                cell.classList.remove('editing');
            }
            
            input.addEventListener('blur', saveEdit);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveEdit();
                } else if (e.key === 'Escape') {
                    cancelEdit();
                }
            });
        }
        
        // Concurrency chart
        let concurrencyChart = null;
        
        function initConcurrencyChart() {
            if (concurrencyChart) {
                concurrencyChart.destroy();
            }
            
            const ctx = document.getElementById('concurrencyChart').getContext('2d');
            const hostedCustomers = customers.filter(c => c.isHosted !== false);
            
            // Generate last 7 days
            const dates = [];
            for (let i = 6; i >= 0; i--) {
                const date = new Date();
                date.setDate(date.getDate() - i);
                dates.push(date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
            }
            
            const colors = ['#667eea', '#f093fb', '#4facfe', '#43e97b', '#fa709a', '#fee140', '#30cfd0', '#a8edea'];
            
            const datasets = hostedCustomers.map((customer, index) => {
                const data = dates.map(() => {
                    const current = customer.currentConcurrency || 0;
                    const variation = (Math.random() - 0.5) * 0.3;
                    return Math.max(0, Math.min(customer.concurrencyLimit, current * (1 + variation)));
                });
                
                return {
                    label: customer.name,
                    data: data,
                    borderColor: colors[index % colors.length],
                    backgroundColor: colors[index % colors.length] + '40',
                    borderWidth: 2,
                    tension: 0.4,
                    fill: false
                };
            });
            
            concurrencyChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: dates,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: { boxWidth: 12, font: { size: 11 } }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y.toFixed(0) + ' concurrent';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: 'Concurrent Connections' }
                        },
                        x: {
                            title: { display: true, text: 'Date' }
                        }
                    }
                }
            });
        }
        
        // Tab switching
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            if (tabName === 'customers') {
                document.getElementById('customersView').classList.add('active');
            } else if (tabName === 'prospects') {
                document.getElementById('prospectsView').classList.add('active');
                renderProspectTable();
            } else if (tabName === 'concurrency') {
                document.getElementById('concurrencyView').classList.add('active');
                renderConcurrencyTables();
                initConcurrencyChart();
            } else if (tabName === 'map') {
                document.getElementById('mapView').classList.add('active');
                initMap();
            } else if (tabName === 'trends') {
                document.getElementById('trendsView').classList.add('active');
                initTrendsChart();
            }
        }
        
        // Chart functionality
        let trendsChart = null;
        let spendChart = null;
        let selectedCustomers = new Set();
        
        function initTrendsChart() {
            // Initialize all customers as selected
            if (selectedCustomers.size === 0) {
                customers.forEach((c, i) => selectedCustomers.add(i));
            }
            renderCustomerFilters();
            initUsageChart();
            initSpendChart();
            renderZeroProjections();
        }
        
        function renderCustomerFilters(searchTerm = '') {
            const container = document.getElementById('customerFilters');
            container.innerHTML = '';
            
            // Sort customers alphabetically
            const sortedCustomers = customers
                .map((c, i) => ({ customer: c, originalIndex: i }))
                .sort((a, b) => a.customer.name.localeCompare(b.customer.name));
            
            let visibleCount = 0;
            
            sortedCustomers.forEach(({ customer, originalIndex }) => {
                // Filter by search term
                if (searchTerm && !customer.name.toLowerCase().includes(searchTerm.toLowerCase())) {
                    return;
                }
                
                visibleCount++;
                const isChecked = selectedCustomers.has(originalIndex);
                const div = document.createElement('div');
                div.className = 'customer-filter';
                div.innerHTML = `
                    <input type="checkbox" id="filter_${originalIndex}" ${isChecked ? 'checked' : ''} onchange="toggleCustomer(${originalIndex})">
                    <label for="filter_${originalIndex}">${customer.name}</label>
                `;
                container.appendChild(div);
            });
            
            // Update selected count
            document.getElementById('selectedCount').textContent = selectedCustomers.size;
            
            // Update select all checkbox state
            const selectAllCheckbox = document.getElementById('selectAllCheckbox');
            if (selectAllCheckbox) {
                selectAllCheckbox.checked = selectedCustomers.size === customers.length;
                selectAllCheckbox.indeterminate = selectedCustomers.size > 0 && selectedCustomers.size < customers.length;
            }
            
            if (visibleCount === 0) {
                container.innerHTML = '<p style="color: #999; font-size: 11px; margin: 0;">No customers match your search</p>';
            }
        }
        
        function filterCustomerList(searchTerm) {
            renderCustomerFilters(searchTerm);
        }
        
        function toggleAllCustomers(checked) {
            if (checked) {
                customers.forEach((c, i) => selectedCustomers.add(i));
            } else {
                selectedCustomers.clear();
            }
            
            // Get current search term
            const searchTerm = document.getElementById('customerSearch').value;
            renderCustomerFilters(searchTerm);
            initUsageChart();
            renderZeroProjections();
        }
        
        function toggleCustomer(index) {
            if (selectedCustomers.has(index)) {
                selectedCustomers.delete(index);
            } else {
                selectedCustomers.add(index);
            }
            
            // Get current search term
            const searchTerm = document.getElementById('customerSearch').value;
            renderCustomerFilters(searchTerm);
            initUsageChart();
            renderZeroProjections();
        }
        
        function selectAllCustomers() {
            customers.forEach((c, i) => selectedCustomers.add(i));
            const searchTerm = document.getElementById('customerSearch').value;
            renderCustomerFilters(searchTerm);
            initUsageChart();
            renderZeroProjections();
        }
        
        function deselectAllCustomers() {
            selectedCustomers.clear();
            const searchTerm = document.getElementById('customerSearch').value;
            renderCustomerFilters(searchTerm);
            initUsageChart();
            renderZeroProjections();
        }
        
        function calculateZeroDate(customer) {
            const consumed = customer.startingCredits - customer.creditsRemaining;
            if (consumed <= 0) return null; // No consumption yet
            
            // Calculate days since start
            const startDate = new Date(customer.startDate);
            const today = new Date();
            const daysSinceStart = Math.max(1, (today - startDate) / (1000 * 60 * 60 * 24));
            
            // Calculate daily burn rate
            const dailyBurnRate = consumed / daysSinceStart;
            if (dailyBurnRate <= 0) return null;
            
            // Calculate days until zero
            const daysUntilZero = customer.creditsRemaining / dailyBurnRate;
            
            // Calculate zero date
            const zeroDate = new Date();
            zeroDate.setDate(zeroDate.getDate() + daysUntilZero);
            
            return {
                date: zeroDate,
                daysRemaining: Math.ceil(daysUntilZero),
                dailyBurnRate: dailyBurnRate
            };
        }
        
        function renderZeroProjections() {
            const container = document.getElementById('zeroProjections');
            container.innerHTML = '';
            
            const projections = [];
            
            customers.forEach((customer, index) => {
                if (!selectedCustomers.has(index)) return;
                
                const projection = calculateZeroDate(customer);
                if (projection && projection.daysRemaining < 365) {
                    projections.push({
                        customer: customer,
                        ...projection
                    });
                }
            });
            
            // Sort by soonest first
            projections.sort((a, b) => a.daysRemaining - b.daysRemaining);
            
            if (projections.length === 0) {
                container.innerHTML = '<p style="color: #666; margin: 0;">No customers projected to run out of credits in the next year.</p>';
                return;
            }
            
            projections.forEach(p => {
                const urgency = p.daysRemaining < 30 ? 'border-left-color: #dc3545;' : 
                               p.daysRemaining < 90 ? 'border-left-color: #ffc107;' : 
                               'border-left-color: #28a745;';
                
                const div = document.createElement('div');
                div.className = 'zero-date-item';
                div.style = urgency;
                div.innerHTML = `
                    <div class="zero-date-customer">${p.customer.name}</div>
                    <div class="zero-date-date">Zero: ${p.date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}</div>
                    <div style="color: #666; font-size: 10px; margin-top: 2px;">${p.daysRemaining} days | $${p.dailyBurnRate.toFixed(2)}/day</div>
                `;
                container.appendChild(div);
            });
        }
        
        function initUsageChart() {
            if (trendsChart) {
                trendsChart.destroy();
            }
            
            const ctx = document.getElementById('trendsChart').getContext('2d');
            
            // Generate dates for the last 12 months
            const dates = [];
            const today = new Date();
            for (let i = 11; i >= 0; i--) {
                const date = new Date(today);
                date.setMonth(date.getMonth() - i);
                dates.push(date.toLocaleDateString('en-US', { month: 'numeric', day: 'numeric', year: 'numeric' }));
            }
            
            // Generate datasets for selected customers only
            const colors = [
                '#667eea', '#f093fb', '#4facfe', '#43e97b', '#fa709a',
                '#fee140', '#30cfd0', '#a8edea', '#ff6b6b', '#4ecdc4',
                '#cd84f1', '#ffccbc', '#c5e1a5', '#80deea', '#ce93d8',
                '#f48fb1', '#90caf9', '#a5d6a7', '#ffab91', '#bcaaa4',
                '#b39ddb', '#81c784', '#64b5f6', '#ffb74d', '#9575cd',
                '#4db6ac', '#aed581'
            ];
            
            const datasets = customers.filter((c, i) => selectedCustomers.has(i)).map((customer, index) => {
                // Generate realistic usage data based on credits consumed
                const totalConsumed = customer.startingCredits - customer.creditsRemaining;
                const avgMonthlyUsage = totalConsumed / 12; // Rough average
                
                // Create data with some variation
                const data = dates.map(() => {
                    const variation = (Math.random() - 0.5) * 0.4; // ¬±20% variation
                    const baseValue = avgMonthlyUsage * 0.001; // Convert to hours (rough estimate)
                    return Math.max(0, baseValue * (1 + variation));
                });
                
                return {
                    label: customer.name,
                    data: data,
                    borderColor: colors[index % colors.length],
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    tension: 0.4,
                    pointRadius: 2,
                    pointHoverRadius: 5,
                    pointBackgroundColor: colors[index % colors.length],
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2
                };
            });
            
            trendsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: dates,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                boxWidth: 12,
                                padding: 8,
                                font: {
                                    size: 11
                                },
                                usePointStyle: true,
                                pointStyle: 'circle'
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    label += context.parsed.y.toFixed(2) + ' hours';
                                    return label;
                                }
                            }
                        },
                        title: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Sum of Total Duration Hours',
                                font: {
                                    size: 12
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return value.toLocaleString();
                                }
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Date',
                                font: {
                                    size: 12
                                }
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45,
                                font: {
                                    size: 10
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function initSpendChart() {
            if (spendChart) {
                spendChart.destroy();
            }
            
            const ctx = document.getElementById('spendChart').getContext('2d');
            
            // Generate dates for the last 12 months
            const dates = [];
            const today = new Date();
            for (let i = 11; i >= 0; i--) {
                const date = new Date(today);
                date.setMonth(date.getMonth() - i);
                dates.push(date.toLocaleDateString('en-US', { month: 'short', year: '2-digit' }));
            }
            
            // Product types and their colors
            const productTypes = {
                'Batch STT': { color: '#1976D2', data: [] },
                'Realtime STT': { color: '#388E3C', data: [] },
                'Voice Agent API': { color: '#7B1FA2', data: [] },
                'Flux': { color: '#F57C00', data: [] },
                'Medical': { color: '#00796B', data: [] },
                'TTS': { color: '#C2185B', data: [] },
                'Language Expansion': { color: '#6A1B9A', data: [] }
            };
            
            // Calculate spend by product for each month
            dates.forEach((date, monthIndex) => {
                // Reset monthly totals
                Object.keys(productTypes).forEach(product => {
                    productTypes[product].data[monthIndex] = 0;
                });
                
                // Aggregate spend from all customers
                customers.forEach(customer => {
                    // Calculate monthly spend based on credits consumed
                    const totalConsumed = customer.startingCredits - customer.creditsRemaining;
                    const monthlySpend = totalConsumed / 12; // Rough monthly average
                    
                    // Distribute spend across products customer uses
                    const productCount = customer.products.length;
                    const spendPerProduct = monthlySpend / productCount;
                    
                    // Add variation (¬±30%)
                    const variation = 1 + (Math.random() - 0.5) * 0.6;
                    
                    customer.products.forEach(product => {
                        if (productTypes[product]) {
                            productTypes[product].data[monthIndex] += spendPerProduct * variation;
                        }
                    });
                });
            });
            
            // Create datasets for stacked area chart
            const datasets = Object.keys(productTypes).map(product => {
                return {
                    label: product,
                    data: productTypes[product].data,
                    backgroundColor: productTypes[product].color + '80', // Add transparency
                    borderColor: productTypes[product].color,
                    borderWidth: 2,
                    fill: true,
                    tension: 0.4,
                    pointRadius: 0,
                    pointHoverRadius: 4,
                    pointBackgroundColor: productTypes[product].color,
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2
                };
            });
            
            spendChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: dates,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                boxWidth: 12,
                                padding: 15,
                                font: {
                                    size: 12
                                },
                                usePointStyle: true,
                                pointStyle: 'circle'
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    label += '$' + context.parsed.y.toLocaleString('en-US', { 
                                        minimumFractionDigits: 2, 
                                        maximumFractionDigits: 2 
                                    });
                                    return label;
                                },
                                footer: function(tooltipItems) {
                                    let sum = 0;
                                    tooltipItems.forEach(function(tooltipItem) {
                                        sum += tooltipItem.parsed.y;
                                    });
                                    return 'Total: $' + sum.toLocaleString('en-US', { 
                                        minimumFractionDigits: 2, 
                                        maximumFractionDigits: 2 
                                    });
                                }
                            }
                        },
                        title: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            stacked: true,
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Total Spend (USD)',
                                font: {
                                    size: 13,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toLocaleString();
                                }
                            }
                        },
                        x: {
                            stacked: true,
                            title: {
                                display: true,
                                text: 'Month',
                                font: {
                                    size: 13,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                font: {
                                    size: 11
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Map functionality
        let map = null;
        let markers = [];
        
        // Location coordinates mapping (approximate)
        const locationCoords = {
            'Ohio': [40.4173, -82.9071],
            'San Francisco': [37.7749, -122.4194],
            'CA': [36.7783, -119.4179],
            'PA, US': [40.2732, -76.8867],
            'Indianapolis': [39.7684, -86.1581],
            'Singapore': [1.3521, 103.8198],
            'NY, NY': [40.7128, -74.0060],
            'UK': [51.5074, -0.1278],
            'New Jersey': [40.0583, -74.4057],
            'Argentina': [-38.4161, -63.6167],
            'LA, CA': [34.0522, -118.2437],
            'Nashville, TN': [36.1627, -86.7816],
            'Maine': [45.2538, -69.4455],
            'Miami, FL': [25.7617, -80.1918],
            'Santa Clara, CA': [37.3541, -121.9552],
            'Texas': [31.9686, -99.9018],
            'Colorado': [39.5501, -105.7821]
        };
        
        function initMap() {
            if (map) {
                map.invalidateSize();
                return;
            }
            
            // Initialize map centered on US
            map = L.map('map').setView([37.0902, -95.7129], 4);
            
            // Add tile layer
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 18
            }).addTo(map);
            
            // Add markers for each customer
            customers.forEach(customer => {
                const coords = locationCoords[customer.location];
                if (coords) {
                    const pct = (customer.creditsRemaining / customer.startingCredits) * 100;
                    let markerColor = 'green';
                    if (pct < 25) markerColor = 'red';
                    else if (pct < 50) markerColor = 'orange';
                    
                    // Create custom icon
                    const icon = L.divIcon({
                        className: 'custom-marker',
                        html: `<div style="background: ${markerColor}; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>`,
                        iconSize: [12, 12],
                        iconAnchor: [6, 6]
                    });
                    
                    const marker = L.marker(coords, { icon: icon }).addTo(map);
                    
                    // Create popup content
                    const popupContent = `
                        <div class="popup-title">${customer.name}</div>
                        <div class="popup-info">üìç ${customer.location}</div>
                        <div class="popup-info">üíº ${customer.useCase}</div>
                        <div class="popup-info">üì¶ ${customer.products.slice(0, 2).join(', ')}${customer.products.length > 2 ? '...' : ''}</div>
                        <div class="popup-credits" style="color: ${markerColor};">
                            ${pct.toFixed(0)}% Credits Remaining<br>
                            <small>$${customer.creditsRemaining.toLocaleString()} / $${customer.startingCredits.toLocaleString()}</small>
                        </div>
                    `;
                    
                    marker.bindPopup(popupContent);
                    markers.push(marker);
                }
            });
        }
        
        // Initialize
        loadData();
        renderTable();
        renderProspectTable();
        updateStats();
        
        // Add click handlers to sortable headers
        document.querySelectorAll('th.sortable').forEach(th => {
            th.addEventListener('click', () => {
                const column = th.getAttribute('data-sort');
                sortTable(column);
            });
        });
    </script>
</body>
</html>
